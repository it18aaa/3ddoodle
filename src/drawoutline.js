// import "@babylonjs/core/Culling/ray";
// import "@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent";
// import "@babylonjs/core/Materials/standardMaterial";
// import "@babylonjs/core/Layers/effectLayerSceneComponent";
// import "@babylonjs/loaders";
// import "@babylonjs/core/Loading/loadingScreen";
// import { HighlightLayer } from "@babylonjs/core/Layers/highlightLayer";
// import { UtilityLayerRenderer } from "@babylonjs/core/Rendering/utilityLayerRenderer";
import {
    Vector3
} from "@babylonjs/core/Maths/math";
import {
    CubicEase
} from "@babylonjs/core/Animations/easing";
import {
    EasingFunction
} from "@babylonjs/core/Animations/easing"
import {
    Animation
} from "@babylonjs/core/Animations/animation"
// import { PointerEventTypes } from "@babylonjs/core/Events/pointerEvents";
// import { Color3 } from "@babylonjs/core/Maths/math.color";
// //import { PointerDragBehavior } from "@babylonjs/core/Behaviors/Meshes/pointerDragBehavior";
// import { VertexBuffer } from "@babylonjs/core/meshes"

//import { PlaneRotationGizmo } from "@babylonjs/core/Gizmos/planeRotationGizmo";
import {
    Engine
} from "@babylonjs/core/Engines/engine";
import {
    //   createScene,
    createCamera,
    //   createAltScene,
    createOutlineScene,
} from "./modules/scene";
import {
    button,
    button2,
    Dialog,
    rangeSlider
} from "./modules/guiComponents";
import {
    StringLine
} from "./modules/stringLine"

import {
    RibbonFence
} from "./modules/ribbonFence"
import {
    EVENTS,
    EventBus
} from "./modules/eventBus";
import $ from "jquery";
// import { Mesh } from "@babylonjs/core/Meshes/mesh"
import {
    AdvancedDynamicTexture
} from "@babylonjs/gui/2D/advancedDynamicTexture";

import "@babylonjs/core/Debug/debugLayer";
import "@babylonjs/inspector";

import { Camera } from "@babylonjs/core/Cameras/camera";

// init this part of the app
const eventBus = new EventBus();
const canvas = document.getElementById("renderCanvas");
const engine = new Engine(canvas, true, {
    stencil: true,
});

const scene = createOutlineScene(engine);
const adt = new AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene);
const camera = createCamera(canvas, scene);
var counter = 0;

// attach camera to scene to start off with...
camera.attachControl(canvas, false);

let divFps = document.getElementById("fps");
var showfps = 1;

// can this be generated by a button press
const outline = new StringLine(scene, adt, false)

drawGui();


// run the renderloop
engine.runRenderLoop(function () {
    if (showfps) {
        divFps.innerHTML = engine.getFps().toFixed() + " fps";
    }
    scene.render();
});

// helper function to determine if the camera has 
// controls attached to it
function getCameraActive() {
    return camera.inputs.attachedElement ? true : false;
}

// CREATE POLYGON BUTTON
eventBus.subscribe(EVENTS.GUI_POLYGON, (payload) => {
    outline.getPolygonFromLines();
})

// CLEAR BUTTON
eventBus.subscribe(EVENTS.GUI_CLEAR, (payload) => {
    outline.reset();
})

// change between orthographic and perspective view
//
eventBus.subscribe(EVENTS.GUI_CAMERA_ORTHO, (payload) => {
    if (camera.mode == Camera.PERSPECTIVE_CAMERA) {
        // TODO: hardcoded vars
        var distance = 26;
        var aspect = scene.getEngine().getRenderingCanvasClientRect().height / scene.getEngine().getRenderingCanvasClientRect().width;
        camera.orthoLeft = -distance / 3;
        camera.orthoRight = distance / 3;
        camera.orthoBottom = camera.orthoLeft * aspect;
        camera.orthoTop = camera.orthoRight * aspect;
        camera.mode = Camera.ORTHOGRAPHIC_CAMERA;
    };
})
// change to perspective mode
eventBus.subscribe(EVENTS.GUI_CAMERA_PERSPECTIVE, (payload) => {
    if (camera.mode == Camera.ORTHOGRAPHIC_CAMERA) {
        camera.mode = Camera.PERSPECTIVE_CAMERA;
    };
})

// GET LENGTHS BUTTON d
eventBus.subscribe(EVENTS.GUI_LENGTH_BUTTON, (payload) => {
    let lengths = outline.getLengths();

    var classType = outline.constructor.name;

    console.log("classtype: ", outline.constructor.name);
    console.log("super: ", outline);
    console.log(lengths)
    console.log(`total length: `, outline.totalLength)
})


eventBus.subscribe(EVENTS.GUI_BOUNDING, (payload) => {
    outline.updateExtents();
})


// KEEP POLYGON BUTTON
eventBus.subscribe(EVENTS.GUI_KEEP, (payload) => {
    let p = outline.getPolygon();
    if (p) {
        scene.addMesh(p);
    }
    outline.reset();
})


// TUBE!
eventBus.subscribe(EVENTS.GUI_TUBE, payload => {
    outline.getTubeFromLines();
})


// FENCE - currently making a fence!
eventBus.subscribe(EVENTS.GUI_FENCE, payload => {
    var f = new RibbonFence(outline);

    if (payload.height && payload.height > 0.1 && payload.height < 10) {
        f.height = payload.height;
    }
    var mesh = f.getMesh();

    counter++;
    mesh.name = `fence${counter}`;

    scene.addMesh(mesh);
    // mesh.material = scene.getMaterialByName("woodFence");
    mesh.material = scene.getMaterialByName("fence");


})

// CAMERA mode toggle button
eventBus.subscribe(EVENTS.GUI_CAMERA_FREEZE_TOGGLE, (payload) => {

    if (getCameraActive()) {
        // detach mouse controls from camera
        // and set up drawing mode
        camera.detachControl(canvas);
        eventBus.dispatch(EVENTS.CAMERA_FROZEN);
    } else {
        // kill drawing mode and attach
        // mouse input to camera...
        camera.attachControl(canvas, true);
        eventBus.dispatch(EVENTS.CAMERA_UNFROZEN);
    }
});


// debug if enabled
eventBus.subscribe(EVENTS.GUI_DEBUG, payload => {
    if (scene.debugLayer.isVisible()) {
        scene.debugLayer.hide();
    } else {
        scene.debugLayer.show();
    };

})


// listen for mouse right click, but if
// only we're in string line mode .... 
canvas.addEventListener("contextmenu", (evt) => {
    if (!getCameraActive()) {
        let picked = scene.pick(scene.pointerX, scene.pointerY);

        if (picked.pickedMesh && picked.pickedMesh.name.substring(0, 4) == "post") {
            outline.delFencePostByName(picked.pickedMesh.name)
        } else {
            outline.addFencePost(picked.pickedPoint);
        }
    }
});


// listen for double click, focus the camera
canvas.addEventListener("dblclick", function (e) {
    if (getCameraActive()) {
        let picked = scene.pick(scene.pointerX, scene.pointerY);
        animateCameraTo(
            picked.pickedPoint.x, // targetx
            picked.pickedPoint.y,
            picked.pickedPoint.z, //
            camera.position.x,
            5, // location y
            camera.position.z,
            5, // spped
            2) // framecount
    }
})

// animation function adapted from 
// https://www.html5gamedevs.com/topic/37992-animating-arcrotatecamera-settarget/
function animateCameraTo(targetX, targetY, targetZ, locationX, locationY, locationZ, speed, frameCount) {

    let ease = new CubicEase();
    ease.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);

    let activCam = scene.activeCamera;

    let cameraTarget = new Vector3(targetX + (Math.random() * (0.001 - 0.002) + 0.002), targetY, targetZ);

    let cameraPosition = new Vector3(locationX, locationY, locationZ);

    Animation.CreateAndStartAnimation('at4', activCam, 'position', speed, frameCount, activCam.position, cameraPosition, 0, ease);

    Animation.CreateAndStartAnimation('at5', activCam, 'target', speed, frameCount, activCam.target, cameraTarget, 0, ease);
};

// Animation
// Vector3
// CubicEase







// the canvas/window resize event handler
window.addEventListener("resize", function () {
    engine.resize();
});

function drawGui() {

    $(".button-container").remove();

    $("body").append('<div class="button-container">Garden Designer! </div>');

    let cam_default = "Camera Mode";


    button("btnDebug", "debug")
    button("btnFreezeCamera", cam_default);
    button("btnPolygon", "Polygon");
    button("btnClear", "Clear");
    button("btnLength", "Lengths");
    button("btnKeep", "Keep");
    button("btnBounding", "Bounding Box");
    button("btnTube", "Tube");
    button("btnFence", "Fence");
    button("btnCameraPerspective", "Perspective");
    button("btnCameraOrtho", "Orthographic");

    // example of button with built in call back
    button2("btnBiff", "biff", eventBus, () => {
        console.log("Biff pressed");
        eventBus.dispatch(EVENTS.GUI_FENCE, { height: 5 })
    }, "stuff");

    var a = new Dialog('dlgScooby', 'scooby dooby doo!');
    var b = new Dialog('ba', 'wilburforce zed!');


    rangeSlider("rngHeight", "height", 0, 4, .1);

    $("#rngHeight").on('change', function (ev) {
        this.text = "freddo "
    })

    $("#btnFence").on('click', ev => {
        var height = $("#rngHeight").val();
        eventBus.dispatch(EVENTS.GUI_FENCE, {
            height: height
        });
    })

    $("#btnCameraPerspective").on('click', event => {
        eventBus.dispatch(EVENTS.GUI_CAMERA_PERSPECTIVE);
    })

    $("#btnCameraOrtho").on('click', event => {
        eventBus.dispatch(EVENTS.GUI_CAMERA_ORTHO);
    })


    $("#btnTube").on('click', event => {
        eventBus.dispatch(EVENTS.GUI_TUBE);
    });

    $("#btnBounding").on('click', (event) => {
        eventBus.dispatch(EVENTS.GUI_BOUNDING);
    })

    // freeze camera button
    $("#btnFreezeCamera").on('click', (event) => {
        eventBus.dispatch(EVENTS.GUI_CAMERA_FREEZE_TOGGLE);
    });

    $("#btnPolygon").on('click', (event) => {
        eventBus.dispatch(EVENTS.GUI_POLYGON);
    });

    $("#btnClear").on('click', (event) => {
        eventBus.dispatch(EVENTS.GUI_CLEAR);
    });

    $("#btnLength").on('click', (event) => {
        eventBus.dispatch(EVENTS.GUI_LENGTH_BUTTON)
    });

    $("#btnKeep").on('click', (event) => {
        eventBus.dispatch(EVENTS.GUI_KEEP);
    });

    $("#btnDebug").on('click', ev => {
        eventBus.dispatch(EVENTS.GUI_DEBUG)
    })

    // change icon when camera is frozen
    eventBus.subscribe(EVENTS.CAMERA_FROZEN, (payload) => {
        $("#btnFreezeCamera").text("Draw Mode");
        console.log("Draw Mode: Use the mouse to draw the outline of your garden")
    });

    eventBus.subscribe(EVENTS.CAMERA_UNFROZEN, (payload) => {
        $("#btnFreezeCamera").text(cam_default);
        console.log("Camera Mode: use the mouse to move the camera around the scene")
    });
}




// utility method created by CeeJay on html5gameDevs
//

// function setUVScale(mesh, uScale, vScale) {
//   var i,
//     UVs = mesh.getVerticesData(VertexBuffer.UVKind),
//     len = UVs.length;

//   if (uScale !== 1) {
//     for (i = 0; i < len; i += 2) {
//       UVs[i] *= uScale;
//     }
//   }
//   if (vScale !== 1) {
//     for (i = 1; i < len; i += 2) {
//       UVs[i] *= vScale;
//     }
//   }

//   mesh.setVerticesData(VertexBuffer.UVKind, UVs);
// }